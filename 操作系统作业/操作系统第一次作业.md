# 操作系统第一次作业

## 1.什么是前趋图?请画出下列4条语句的前趋图。  

​		**前趋图**是指一个有向无环图,  它用于描述进程之间执行的先后顺序。图中的每个节点均可用于表示一个进程或一段程序,甚  至是一条语句,节点间的有向边则表示两个节点之间所存在的偏序或前趋关系.

~~~mermaid
graph TD
    S1[S1:a=x+y]
    S2[S2:b=z+1]
    S3[S3:c=a-b]
    S4[S4:w=c+1]

    S1 --> S3
    S2 --> S3
    S3 --> S4
~~~



## 2.什么是进程?OS中为什么要引入进程?它会产生什么样的影响?

**进程（Process）**是操作系统进行资源分配和调度的基本单位，是程序在计算机上的一次运行活动。它是一个动态概念，具有以下特点：

- **动态性**：进程是程序的执行过程，有生命周期（创建、运行、结束），而程序是静态的代码集合。
- **并发性**：多个进程可以在操作系统控制下同时运行（并发执行），共享系统资源。
- **独立性**：进程是资源分配的独立单位，每个进程有自己的地址空间、数据、状态等。
- **异步性**：进程的执行顺序和时间不可预知，取决于操作系统调度和资源分配。

操作系统引入进程的主要目的是为了实现**多任务处理**和**资源高效利用**，具体原因包括：

**（1）提高系统资源利用率**

- **CPU和I/O设备分离**：早期计算机中，CPU和I/O设备是串行工作的，CPU在等待I/O操作完成时会闲置。引入进程后，操作系统可以将CPU分配给其他进程，让CPU和I/O设备并行工作，提高资源利用率。
- **多任务并发执行**：通过进程管理，多个程序可以同时运行（并发执行），充分利用系统资源（如CPU、内存、磁盘等）。

**（2）提高系统吞吐量**

- **多任务支持**：用户可以同时运行多个程序（如浏览器、文本编辑器、音乐播放器等），提高系统的整体效率。
- **任务切换**：操作系统通过进程调度，合理分配CPU时间，使得多个任务可以快速切换，提高系统的响应速度和吞吐量。

**（3）提供隔离和保护**

- **地址空间隔离**：每个进程有自己的独立地址空间，防止一个进程的错误影响其他进程。
- **资源隔离**：进程之间的资源（如文件、设备等）是独立的，操作系统通过权限管理确保进程只能访问自己的资源，提高系统的安全性和稳定性。

**（4）简化程序设计**

- **抽象层**：进程为用户提供了一个抽象的执行环境，用户无需关心底层硬件细节，只需编写程序即可。
- **并发模型**：通过进程模型，用户可以设计并发程序，提高程序的执行效率。

OS中引入进程既有积极影响，也有消极影响：

**1）积极影响**

- **提高系统效率**：通过并发执行，系统资源得到充分利用，提高了整体性能。
- **增强用户体验**：用户可以同时运行多个程序，系统响应更快，交互性更强。
- **提高系统灵活性**：进程模型使得系统能够灵活地支持多任务和多用户环境。
- **提供隔离和保护**：进程之间的隔离机制确保系统的稳定性和安全性，防止程序之间的相互干扰。

**（2）消极影响**

- **系统开销**：进程的创建、切换和销毁需要消耗系统资源（如CPU时间、内存等），增加了系统开销。
- **复杂性增加**：进程管理需要处理进程调度、同步、通信等问题，增加了操作系统的复杂性。
- **资源竞争**：多个进程可能会竞争有限的系统资源（如CPU、内存、I/O设备等），可能导致资源瓶颈或死锁问题。
- **上下文切换开销**：进程切换时需要保存和恢复进程的上下文（如寄存器状态、PCB等），频繁切换会降低系统效率。

## 5.叙述组成进程的基本要素,并说明它们的作用。

进程由程序代码、数据、进程控制块、上下文、资源、I/O信息和通信机制等基本要素组成。这些要素共同定义了进程的结构和行为，使得进程能够独立运行、与其他进程协作，并在操作系统中高效地完成任务。

1. **程序代码**：定义进程的执行逻辑和行为，是进程运行的基础。
2. **数据**：存储进程运行时的变量和信息，支持动态操作和状态管理。
3. **进程控制块（PCB）**：记录进程的状态和上下文信息，是操作系统管理和调度进程的核心数据结构。
4. **上下文**：保存进程的运行环境信息，用于进程切换时恢复执行状态。
5. **资源**：为进程提供运行所需的硬件和软件资源，支持其执行和功能实现。
6. **I/O信息**：管理进程的输入输出请求和状态，协调进程与I/O设备之间的交互。
7. **通信机制**：支持进程之间的数据交换和协作，实现同步和资源共享。

## 6.(考研真题)请给出PCB的主要内容。描述当进程状态发生转换(就绪→运行、运行→  阻塞)时,OS需要使用/修改PCB的哪些内容?

PCB是操作系统用于管理和调度进程的核心数据结构，主要内容包括：

1. **进程状态**：记录进程当前的状态（运行态、就绪态、阻塞态等），用于操作系统调度和管理进程。
2. **上下文信息**：保存进程的程序计数器（PC）、寄存器状态和栈指针等信息，用于进程切换时恢复执行环境。
3. **进程标识符**：包含进程ID（PID）和父进程ID（PPID），用于唯一标识进程及其关系。
4. **资源分配信息**：记录进程占用的内存、I/O设备、文件等资源，便于操作系统进行资源管理和分配。
5. **优先级信息**：存储进程的静态和动态优先级，用于调度算法确定进程的执行顺序。
6. **调度信息**：记录进程在调度队列中的位置、时间片大小等信息，支持调度算法的运行。
7. **I/O信息**：记录进程的I/O请求和状态，用于管理进程的I/O操作和阻塞条件。

（1）**就绪态 → 运行态**

当操作系统从就绪队列中选择一个进程投入运行时，会进行以下操作：

- **修改进程状态**：
  - 将PCB中的状态从“就绪态”改为“运行态”。
- **恢复上下文信息**：
  - 将PCB中保存的程序计数器（PC）、寄存器状态、栈指针等上下文信息加载到CPU的相应寄存器中。
- **更新调度信息**：
  - 如果使用轮转调度（Round-Robin），更新进程的时间片信息。
- **资源分配**：
  - 确保进程所需的资源（如内存、I/O设备）已经分配完毕，如果未分配，则完成分配。

（2）**运行态 → 阻塞态**

当进程在运行过程中因某些事件（如等待I/O操作完成）而无法继续执行时，会发生运行态到阻塞态的转换。操作系统会进行以下操作：

- **修改进程状态**：
  - 将PCB中的状态从“运行态”改为“阻塞态”。
- **保存上下文信息**：
  - 将当前运行进程的程序计数器（PC）、寄存器状态、栈指针等上下文信息保存到PCB中。
- **更新I/O信息**：
  - 在PCB中记录进程等待的I/O请求或事件类型，以便在事件完成后唤醒进程。
- **更新调度信息**：
  - 将进程从运行队列中移除，并将其加入到阻塞队列中。
- **资源释放**：
  - 如果进程在阻塞期间不需要某些资源（如CPU时间），可以暂时释放这些资源，供其他进程使用。

## 7.试说明引起进程创建的主要事件。

1. **系统初始化**：操作系统启动时创建初始进程（如`init`进程），为系统运行提供基础服务和管理功能。
2. **用户登录**：用户登录系统时创建登录进程（如终端会话进程），为用户提供交互环境和服务。
3. **运行程序**：用户或系统运行一个程序时，创建新进程来执行该程序，实现程序的功能。
4. **系统调用**：程序通过系统调用（如`fork()`或`CreateProcess()`）请求创建子进程，用于并发执行或实现特定功能。
5. **提供服务**：系统启动守护进程（如网络服务、定时任务等）时，创建新进程以提供后台服务。
6. **批处理作业**：在批处理系统中，作业调度程序根据作业请求创建进程，执行批处理任务。

## 8.(考研真题)在创建一个进程时,OS需要完成的主要工作是什么?

1. **分配一个唯一的进程标识符（PID）**：为新进程分配一个唯一的标识符，以便在系统中区分和管理进程。
2. **分配内存空间**：为进程分配必要的内存资源，包括代码段、数据段、堆和栈空间。
3. **初始化进程控制块（PCB）**：创建并初始化进程控制块，记录进程的状态、上下文信息、资源分配等关键数据。
4. **设置上下文环境**：配置进程的初始上下文，包括程序计数器（PC）、寄存器状态和栈指针等，以便进程能够正确开始执行。
5. **分配必要的系统资源**：为进程分配所需的其他资源，如文件描述符、I/O设备、信号量等。
6. **加载程序和数据**：将程序代码和初始数据从磁盘加载到分配的内存空间中，为进程的运行做好准备。

## 11.试说明引起进程阻塞或被唤醒的主要事件。

**进程阻塞**：

1. I/O操作请求。
2. 资源分配请求。
3. 用户输入请求。
4. 进程间同步（如信号量、互斥锁）。
5. 等待子进程结束（如`wait()`）。
6. 时间延迟或睡眠（如`sleep()`）。
7. 消息队列或缓冲区不可用。

**进程唤醒**：

1. I/O操作完成。
2. 资源分配完成。
3. 用户输入完成。
4. 同步条件满足（如信号量释放）。
5. 子进程结束。
6. 睡眠时间到期。
7. 消息队列或缓冲区可用。

## 12.试比较进程间的低级与高级通信工具。  

| 比较维度       | 低级通信工具                               | 高级通信工具                                       |
| :------------- | :----------------------------------------- | :------------------------------------------------- |
| **通信机制**   | 基于系统调用（共享内存、消息队列、管道等） | 基于抽象接口（RPC、消息中间件、套接字封装等）      |
| **典型工具**   | 共享内存、消息队列、管道、信号             | RPC、分布式对象（CORBA）、消息中间件、套接字封装   |
| **实现复杂度** | 高，需要手动管理同步和互斥                 | 低，封装了底层细节，提供高级抽象接口               |
| **开发难度**   | 高，需要深入理解操作系统原理和同步机制     | 低，易于使用，适合快速开发                         |
| **性能开销**   | 低，通信效率高，适合对性能要求高的场景     | 高，封装层增加了通信开销，适合对性能要求较低的场景 |
| **功能丰富度** | 功能相对简单，适合基本的进程间通信         | 功能强大，支持复杂的数据结构和通信模式             |
| **可移植性**   | 差，依赖于操作系统提供的系统调用           | 好，通常基于标准化协议和跨平台库                   |
| **适用场景**   | 对性能要求高、需要精细控制同步和互斥的场景 | 开发效率要求高、分布式系统、大规模应用             |
| **同步机制**   | 显式同步（信号量、互斥锁等）               | 隐式同步（封装在通信框架中）                       |
| **错误处理**   | 需要开发者手动处理死锁、竞态条件等问题     | 框架通常提供错误处理机制，但灵活性受限             |
| **依赖性**     | 依赖操作系统内核支持                       | 依赖外部库或框架                                   |
| **跨平台支持** | 通常局限于特定操作系统                     | 跨平台支持良好，可在多种操作系统间使用             |

## 13.当前有哪几种高级通信机制?  

1. **远程过程调用（RPC）**：允许客户端像调用本地函数一样调用远程服务器上的服务，隐藏了底层通信细节。
2. **消息中间件（Message Queue）**：通过消息队列实现异步通信，支持高并发和解耦，适用于分布式系统和微服务架构。
3. **Web服务（Web Services）**：基于HTTP/HTTPS协议，使用RESTful API或SOAP实现跨平台、跨语言的通信，广泛用于互联网和企业级应用。
4. **分布式对象系统（如CORBA）**：通过对象代理实现跨网络的对象调用，支持跨语言和跨平台的分布式对象通信。

## 14.试说明使用管道文件(pipe文件)进行通信的优缺点。 

 **优点**

1. **实现简单**：基于文件系统接口，易于理解和使用，适合轻量级通信。
2. **性能开销小**：适合传输少量数据，通信开销较低。
3. **易于集成**：可以利用标准 I/O 函数操作，便于与其他工具和程序结合使用。
4. **跨平台支持**：大多数操作系统（如 Unix/Linux 的 FIFO 和 Windows 的 Named Pipe）都提供了对管道文件的支持。
5. **同步机制简单**：支持阻塞和非阻塞模式，能够满足基本的同步需求。

**缺点**

1. **功能有限**：不适合传输大量数据，性能可能成为瓶颈。
2. **适用范围窄**：主要用于具有亲缘关系的进程间通信，不支持跨主机通信。
3. **同步能力弱**：无法满足复杂的同步需求，功能较为简单。
4. **安全性问题**：如果管道文件被恶意访问或篡改，可能引发安全问题。
5. **灵活性不足**：功能固定，难以扩展或定制复杂的通信协议。
6. **资源管理问题**：如果管道文件未正确关闭，可能导致资源泄漏。

## 15.试比较直接通信方式和间接通信方式。

| **方面**           | **直接通信方式**                               | **间接通信方式**                               |
| ------------------ | ---------------------------------------------- | ---------------------------------------------- |
| **定义**           | 发送方直接将消息发送给接收方，需指定接收方标识 | 发送方将消息发送到中间实体，接收方从中读取消息 |
| **通信模式**       | 点对点通信，需明确指定通信对象                 | 通过中间实体（如消息队列、共享内存等）进行通信 |
| **实现机制**       | 发送方直接调用接收方的通信接口                 | 发送方和接收方通过中间实体间接交互             |
| **通信开销**       | 通常较小，通信效率高                           | 可能较大，但适合复杂场景                       |
| **适用场景**       | 适用于一对一通信，实时性要求高的场景           | 适用于一对多、多对多通信，复杂系统             |
| **优点**           | - 实现简单<br>- 通信效率高<br>- 实时性好       | - 灵活性高<br>- 可靠性高<br>- 适合复杂场景     |
| **缺点**           | - 灵活性差<br>- 可靠性低<br>- 可能阻塞         | - 实现复杂<br>- 通信开销可能较大               |
| **同步需求**       | 需要发送方和接收方同步等待                     | 发送方和接收方可异步操作，灵活性更高           |
| **扩展性**         | 扩展困难，难以支持多对多通信                   | 易于扩展，支持多对多通信                       |
| **典型实现**       | 管道（Pipe）、信号（Signal）                   | 消息队列、共享内存、套接字、消息中间件         |
| **适用的系统类型** | 小型系统、实时系统                             | 大型分布式系统、微服务架构                     |

## 16.为什么要在OS中引入线程?  

​		引入线程是为了提高系统的并发性和资源利用率，同时简化程序设计并提升程序的响应速度。线程作为比进程更轻量级的执行单位，能够共享进程资源，减少切换开销，充分利用多核处理器的并行能力，支持复杂的模块化设计和交互式应用的快速响应。此外，线程还适应了分布式计算和微服务架构的需求，使得程序能够更高效地执行多任务操作，从而显著提升系统的整体性能和用户体验。

## 17.试说明线程的属性。

1. **轻量级**：线程的创建、切换和销毁开销小，比进程更轻量级。
2. **共享资源**：线程共享所属进程的资源，如内存空间和文件描述符。
3. **独立调度**：线程是独立调度的基本单位，可以独立于其他线程执行。
4. **并发执行**：线程可以同时在多核处理器上执行，实现并行计算。
5. **依赖于进程**：线程必须隶属于某个进程，其生命周期依赖于所属进程。
6. **同步与互斥**：线程间需要同步和互斥机制来避免数据竞争和不一致问题。
7. **独立执行路径**：每个线程有独立的程序计数器、寄存器状态和栈空间。
8. **可以并发或串行执行**：线程可以同时执行（并发）或交替执行（串行）。
9. **可以被阻塞或唤醒**：线程在等待资源时可以被阻塞，条件满足时可以被唤醒。
10. **可以创建和销毁**：线程可以动态创建和销毁，由创建它的线程或进程管理。

## 18.何谓用户级线程和内核支持线程?  

**用户级线程**：由用户空间中的线程库管理的线程，操作系统内核不直接感知其存在。线程的创建、调度和上下文切换都在用户空间完成，通常具有轻量级和快速切换的特点，但无法直接利用多核处理器的并行性。

**内核支持线程**：由操作系统内核直接管理的线程，内核负责线程的创建、调度和上下文切换。内核级线程可以直接利用多核处理器的并行性，支持真正的并行执行，但创建和切换开销相对较大。

## 19.(考研真题)用户级线程和内核支持线程有何区别?

| **方面**             | **用户级线程（User-Level Threads）**                       | **内核支持线程（Kernel-Level Threads）**                     |
| -------------------- | ---------------------------------------------------------- | ------------------------------------------------------------ |
| **定义**             | 由用户空间管理的线程，内核不感知其存在                     | 由操作系统内核直接管理的线程，内核负责调度和管理             |
| **创建和销毁**       | 创建和销毁开销小，由用户空间管理                           | 创建和销毁开销较大，由内核管理                               |
| **切换开销**         | 切换开销小，仅涉及用户空间上下文切换                       | 切换开销较大，涉及内核空间上下文切换                         |
| **调度机制**         | 由用户空间的线程库（如`pthreads`）调度                     | 由操作系统内核调度                                           |
| **是否支持多核并行** | 不支持多核并行，只能在单个进程中串行执行                   | 支持多核并行，可被分配到不同核心上                           |
| **系统资源分配**     | 共享进程的系统资源，无法独立获取资源                       | 可以独立获取系统资源（如文件描述符、内存空间等）             |
| **适用场景**         | I/O密集型应用、轻量级任务切换频繁的场景                    | CPU密集型应用、需要充分利用多核并行性的场景                  |
| **优点**             | - 创建和切换快<br>- 独立于内核调度<br>- 适合轻量级任务     | - 支持多核并行<br>- 独立资源分配<br>- 适合高性能计算         |
| **缺点**             | - 无法利用多核并行<br>- 受限于单个进程<br>- 需要线程库支持 | - 创建和切换开销大<br>- 受内核调度策略限制<br>- 系统调用开销大 |
| **典型实现**         | POSIX线程（`pthreads`）、用户级线程库                      | 多核操作系统（如Linux、Windows）中的线程                     |

## 22.(考研真题)现代OS一般都提供多进程(或称多任务)运行环境,回答以下问题。  

### (1)为支持多进程的并发执行,系统必须建立哪些关于进程的数据结构?  

进程控制块，就绪队列，阻塞队列，进程表，资源分配表。

### (2)为支持进程状态的变迁,系统至少应提供哪些进程控制原语?  

创建原语，调度原语，阻塞原语，唤醒原语，中止原语，等待原语

### (3)在执行每一个进程控制原语时,进程状态会发生什么变化?相应的数据结构会发生什么变化?

| **进程控制原语**                  | **进程状态变化**                                             | **数据结构变化**                                             |
| :-------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **创建原语（Create）**            | 无 → 就绪态                                                  | 1. 分配并初始化PCB。<br>2. 分配内存和其他资源。<br>3. 将进程插入就绪队列。 |
| **调度原语（Dispatch/Schedule）** | 就绪态 → 运行态                                              | 1. 从就绪队列中选择进程。<br>2. 恢复进程上下文。<br>3. 更新PCB状态为“运行态”。 |
| **阻塞原语（Block）**             | 运行态 → 阻塞态                                              | 1. 保存进程上下文。<br>2. 更新PCB状态为“阻塞态”。<br>3. 将进程插入阻塞队列。 |
| **唤醒原语（Wake Up）**           | 阻塞态 → 就绪态                                              | 1. 从阻塞队列中移除进程。<br>2. 更新PCB状态为“就绪态”。<br>3. 将进程插入就绪队列。 |
| **终止原语（Terminate）**         | 运行态/就绪态/阻塞态 → 终止态                                | 1. 释放PCB和进程占用的资源。<br>2. 从就绪队列或阻塞队列中移除进程。<br>3. 通知父进程（如果需要）。 |
| **等待原语（Wait）**              | 父进程：运行态 → 阻塞态<br>子进程：运行态/就绪态/阻塞态 → 终止态 | 1. 父进程保存上下文并进入阻塞态。<br>2. 父进程插入阻塞队列。<br>3. 子进程终止时，唤醒父进程。 |

## 1.什么是临界资源?什么是临界区?  

**临界资源**是指一次只能被一个进程（或线程）访问的共享资源。这种资源在并发执行的环境中必须被互斥访问，以避免数据不一致或其他冲突问题。临界资源可以是硬件资源（如打印机、磁带驱动器）、软件资源（如共享变量、文件、数据库等）。

**临界区**是指访问临界资源的代码段。它是程序中需要互斥执行的部分，确保在任何时刻只有一个进程（或线程）可以进入临界区访问临界资源。

## 2.同步机制应遵循的准则有哪些?  

1. **互斥性**：一次只能有一个进程或线程进入临界区。
2. **有限等待**：请求进入临界区的进程或线程必须在有限时间内获得访问权。
3. **非阻塞**：进程或线程在请求进入临界区时不应无限期等待。
4. **高内聚性**：临界区的代码应尽可能短小，减少其他进程或线程的等待时间。
5. **公平性**：所有请求访问临界区的进程或线程都有平等的机会获得访问权。
6. **安全性**：同步机制应确保不会引入新的错误或死锁问题。

## 3.为什么各进程对临界资源的访问必须互斥?  

​		因为临界资源在同一时间只能被一个进程访问，否则会导致数据不一致、冲突或错误的结果。如果多个进程同时访问临界资源，可能会引发竞争条件，使得资源的状态变得不可预测，进而破坏系统的正确性和稳定性。互斥访问确保了在任何时刻只有一个进程可以操作临界资源，从而避免了数据竞争和冲突，保证了资源的完整性和系统的可靠性。

## 4.如何保证各进程互斥地访问临界资源?

​		为了保证各进程互斥地访问临界资源，操作系统通常采用同步机制，如互斥锁、信号量或条件变量等。这些机制通过在临界区的入口和出口处添加同步操作，确保在同一时刻只有一个进程能够进入临界区访问共享资源。当一个进程进入临界区时，它会获取一个锁或信号量，从而阻止其他进程进入；当该进程退出临界区时，它会释放锁或信号量，允许其他进程获取访问权。通过这种方式，互斥机制有效地避免了多个进程同时访问临界资源而导致的竞争条件和数据不一致问题，从而保证了系统的正确性和稳定性。

## 8.(考研真题)如果用于进程同步的信号量的P、V操作不用原语实现,则会产生什么后果?举例说明。  

**1. 竞争条件**

如果P操作和V操作不是原子操作（即不是原语实现），多个进程在执行这些操作时可能会发生竞争条件。例如，当两个进程几乎同时对同一个信号量执行P操作时，可能会出现以下情况：

- 进程A 和 进程B 同时读取信号量的值。
- 假设信号量的初始值为1，进程A 和 进程B 都读取到值为1。
- 进程A 和 进程B 都将信号量的值减1，此时信号量的值被错误地减为-1，而不是0。
- 结果是两个进程都认为自己获得了资源，从而导致资源被重复访问，破坏了互斥性。

------

**2. 死锁**

如果P操作和V操作不是原子的，可能会导致进程陷入死锁。例如：

- 进程A 执行P操作，试图获取信号量，但信号量的值为0，因此 进程A 阻塞。
- 在 进程A 阻塞之前，它可能已经修改了信号量的值，但尚未完成阻塞操作。
- 进程B 执行V操作，试图释放信号量，但由于 进程A 的操作未完成，信号量的状态可能不一致，导致 进程B 的释放操作无法正确唤醒 进程A。
- 结果是 进程A 永远阻塞，而 进程B 无法继续执行，导致死锁。

------

**3. 信号量状态不一致**

如果P操作和V操作不是原子的，信号量的状态可能会变得不一致。例如：

- 进程A 执行P操作，将信号量的值减1，但尚未完成阻塞操作。
- 进程B 同时执行V操作，试图将信号量的值加1。
- 由于两个操作不是原子的，信号量的值可能被错误地修改，导致信号量的状态与实际的进程状态不一致。

## 9.AND信号量机制的基本思想是什么?它能解决什么问题?  

​		AND信号量机制是一种扩展的信号量机制，用于解决多个信号量同时满足条件时才能执行某个操作的问题。其核心思想是引入一种特殊的等待操作（P操作），使得进程只有在多个信号量的值都满足条件时，才能进入临界区。这种机制通过“AND条件”（即所有信号量都满足）来控制进程的同步行为。

​		AND信号量机制主要解决多条件同步问题，避免死锁和饥饿，简化同逻辑。

## 10.利用信号量机制实现进程互斥时,针对互斥信号量的wait()和signal()操作为什么要成对出现?

​		在利用信号量机制实现进程互斥时，针对互斥信号量的 wait() 和 signal() 操作必须成对出现，这是因为它们分别用于进入和退出临界区，确保对共享资源的互斥访问。wait() 操作用于在进入临界区前检查信号量是否可用，若信号量值大于零则将其减一并进入临界区，否则进程阻塞等待；而 signal() 操作用于在退出临界区时释放信号量，将信号量值加一并唤醒可能等待的其他进程。这种成对出现的机制保证了信号量的值始终正确反映资源的可用性，避免了资源被重复访问或未正确释放，从而确保了临界区的互斥性和系统的稳定性。

## 13.若信号量的初值为2,当前值为-1,则表示有多少个等待进程?请分析。

有1个等待进程

信号量的初值为2，表示最初有2个资源可用。当前值为-1，表示有1个进程正在等待资源。信号量的值为负数时，其绝对值表示等待资源的进程数量。

## 17.(考研真题)银行营业员与顾客之间互斥与同步

**信号量定义及含义**

1. **`mutex`**：用于保护取号机的互斥访问。初值为1。
2. **`customers`**：用于表示等待服务的顾客数量。初值为0。
3. **`seats`**：用于表示空闲座位的数量。初值为10。
4. **`service`**：用于营业员和顾客之间的同步，确保营业员只有在有顾客时才叫号。初值为0。

~~~c
// 信号量定义及初值
semaphore mutex = 1;       // 保护取号机的互斥访问
semaphore customers = 0;   // 等待服务的顾客数量
semaphore seats = 10;      // 空闲座位的数量
semaphore service = 0;     // 营业员和顾客之间的同步

cobegin {
    // 顾客进程
    process 顾客 i {
        P(seats);           // 检查是否有空座位
        P(mutex);           // 互斥访问取号机
        从取号机上获得一个号码;
        V(mutex);           // 释放取号机
        V(customers);       // 增加等待服务的顾客数量
        V(service);         // 唤醒营业员
        V(seats);           // 释放座位
        P(service);         // 等待叫号
        获得服务;           // 获得服务
    }

    // 营业员进程
    process 营业员 {
        while (TRUE) {
            P(customers);   // 等待有顾客
            P(service);     // 等待顾客准备好
            叫号;           // 叫号选取一位顾客
            V(service);     // 唤醒顾客
            为顾客服务;     // 为顾客服务
        }
    }
} coend
~~~

20.桌上有一个能盛得下5个水果的空盘子。爸爸不停地向盘中放苹果和橘子,儿子不停  地从盘中取出橘子享用,女儿不停地从盘中取出苹果享用。规定3人不能同时向(从)盘子中放  (取)水果。试用信号量机制来实现爸爸、儿子和女儿这3个“循环进程”之间的同步。

**信号量定义及含义**

1. **`mutex`**：用于保护盘子的互斥访问。初值为1。
2. **`apples`**：用于表示盘子中苹果的数量。初值为0。
3. **`oranges`**：用于表示盘子中橘子的数量。初值为0。
4. **`empty_slots`**：用于表示盘子中空位的数量。初值为5。

~~~c
// 信号量定义及初值
semaphore mutex = 1;       // 保护盘子的互斥访问
semaphore apples = 0;      // 盘子中苹果的数量
semaphore oranges = 0;     // 盘子中橘子的数量
semaphore empty_slots = 5; // 盘子中空位的数量

cobegin {
    // 爸爸进程
    process 爸爸 {
        while (TRUE) {
            P(empty_slots);  // 检查是否有空位
            P(mutex);        // 互斥访问盘子
            向盘中放一个水果; // 放苹果或橘子
            V(mutex);        // 释放盘子
            V(apples);       // 增加苹果数量
            V(oranges);      // 增加橘子数量
        }
    }

    // 儿子进程
    process 儿子 {
        while (TRUE) {
            P(oranges);      // 等待有橘子
            P(mutex);        // 互斥访问盘子
            从盘中取出一个橘子; // 取橘子
            V(mutex);        // 释放盘子
            V(empty_slots);  // 增加空位数量
        }
    }

    // 女儿进程
    process 女儿 {
        while (TRUE) {
            P(apples);       // 等待有苹果
            P(mutex);        // 互斥访问盘子
            从盘中取出一个苹果; // 取苹果
            V(mutex);        // 释放盘子
            V(empty_slots);  // 增加空位数量
        }
    }
} coend
~~~

